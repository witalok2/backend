{"remainingRequest":"/home/witalo/go/src/github.com/witalok2/application/frontend/node_modules/babel-loader/lib/index.js!/home/witalo/go/src/github.com/witalok2/application/frontend/node_modules/quasar/src/components/table/table-header.js","dependencies":[{"path":"/home/witalo/go/src/github.com/witalok2/application/frontend/node_modules/quasar/src/components/table/table-header.js","mtime":499162500000},{"path":"/home/witalo/go/src/github.com/witalok2/application/frontend/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/witalo/go/src/github.com/witalok2/application/frontend/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.array.sort\";\nimport QLinearProgress from \"../linear-progress/QLinearProgress.js\";\nimport QCheckbox from \"../checkbox/QCheckbox.js\";\nimport QTh from \"./QTh.js\";\nexport default {\n  methods: {\n    getTableHeader: function getTableHeader(h) {\n      var child = [this.getTableHeaderRow(h)];\n      this.loading === true && child.push(h('tr', {\n        staticClass: 'q-table__progress'\n      }, [h('th', {\n        staticClass: 'relative-position',\n        attrs: {\n          colspan: '100%'\n        }\n      }, [h(QLinearProgress, {\n        staticClass: 'q-table__linear-progress',\n        props: {\n          color: this.color,\n          dark: this.dark,\n          indeterminate: true\n        }\n      })])]));\n      return h('thead', child);\n    },\n    getTableHeaderRow: function getTableHeaderRow(h) {\n      var _this = this;\n\n      var header = this.$scopedSlots.header,\n          headerCell = this.$scopedSlots['header-cell'];\n\n      if (header !== void 0) {\n        return header(this.addTableHeaderRowMeta({\n          header: true,\n          cols: this.computedCols,\n          sort: this.sort,\n          colsMap: this.computedColsMap\n        }));\n      }\n\n      var mapFn;\n\n      if (headerCell !== void 0) {\n        mapFn = function mapFn(col) {\n          return headerCell({\n            col: col,\n            cols: _this.computedCols,\n            sort: _this.sort,\n            colsMap: _this.computedColsMap\n          });\n        };\n      } else {\n        mapFn = function mapFn(col) {\n          var props = {\n            col: col,\n            cols: _this.computedCols,\n            sort: _this.sort,\n            colsMap: _this.computedColsMap\n          };\n\n          var slot = _this.$scopedSlots[\"header-cell-\".concat(col.name)];\n\n          return slot !== void 0 ? slot(props) : h(QTh, {\n            key: col.name,\n            props: {\n              props: props\n            },\n            style: col.style,\n            class: col.classes\n          }, col.label);\n        };\n      }\n\n      var child = this.computedCols.map(mapFn);\n\n      if (this.singleSelection === true && this.grid !== true) {\n        child.unshift(h('th', {\n          staticClass: 'q-table--col-auto-width'\n        }, [' ']));\n      } else if (this.multipleSelection === true) {\n        child.unshift(h('th', {\n          staticClass: 'q-table--col-auto-width'\n        }, [h(QCheckbox, {\n          props: {\n            color: this.color,\n            value: this.someRowsSelected ? null : this.allRowsSelected,\n            dark: this.dark,\n            dense: this.dense\n          },\n          on: {\n            input: function input(val) {\n              if (_this.someRowsSelected) {\n                val = false;\n              }\n\n              _this.__updateSelection(_this.computedRows.map(function (row) {\n                return row[_this.rowKey];\n              }), _this.computedRows, val);\n            }\n          }\n        })]));\n      }\n\n      return h('tr', {\n        style: this.tableHeaderStyle,\n        class: this.tableHeaderClass\n      }, child);\n    },\n    addTableHeaderRowMeta: function addTableHeaderRowMeta(data) {\n      var _this2 = this;\n\n      if (this.multipleSelection === true) {\n        Object.defineProperty(data, 'selected', {\n          get: function get() {\n            return _this2.someRowsSelected ? 'some' : _this2.allRowsSelected;\n          },\n          set: function set(val) {\n            if (_this2.someRowsSelected) {\n              val = false;\n            }\n\n            _this2.__updateSelection(_this2.computedRows.map(function (row) {\n              return row[_this2.rowKey];\n            }), _this2.computedRows, val);\n          },\n          configurable: true,\n          enumerable: true\n        });\n        data.partialSelected = this.someRowsSelected;\n        data.multipleSelect = true;\n      }\n\n      return data;\n    }\n  }\n};",{"version":3,"sources":["/home/witalo/go/src/github.com/witalok2/application/frontend/node_modules/quasar/src/components/table/table-header.js"],"names":["QLinearProgress","QCheckbox","QTh","methods","getTableHeader","h","child","getTableHeaderRow","loading","push","staticClass","attrs","colspan","props","color","dark","indeterminate","header","$scopedSlots","headerCell","addTableHeaderRowMeta","cols","computedCols","sort","colsMap","computedColsMap","mapFn","col","slot","name","key","style","class","classes","label","map","singleSelection","grid","unshift","multipleSelection","value","someRowsSelected","allRowsSelected","dense","on","input","val","__updateSelection","computedRows","row","rowKey","tableHeaderStyle","tableHeaderClass","data","Object","defineProperty","get","set","configurable","enumerable","partialSelected","multipleSelect"],"mappings":"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","sourcesContent":["import QLinearProgress from '../linear-progress/QLinearProgress.js'\nimport QCheckbox from '../checkbox/QCheckbox.js'\nimport QTh from './QTh.js'\n\nexport default {\n  methods: {\n    getTableHeader (h) {\n      const child = [ this.getTableHeaderRow(h) ]\n\n      this.loading === true && child.push(\n        h('tr', { staticClass: 'q-table__progress' }, [\n          h('th', { staticClass: 'relative-position', attrs: { colspan: '100%' } }, [\n            h(QLinearProgress, {\n              staticClass: 'q-table__linear-progress',\n              props: {\n                color: this.color,\n                dark: this.dark,\n                indeterminate: true\n              }\n            })\n          ])\n        ])\n      )\n\n      return h('thead', child)\n    },\n\n    getTableHeaderRow (h) {\n      const\n        header = this.$scopedSlots.header,\n        headerCell = this.$scopedSlots['header-cell']\n\n      if (header !== void 0) {\n        return header(this.addTableHeaderRowMeta({\n          header: true, cols: this.computedCols, sort: this.sort, colsMap: this.computedColsMap\n        }))\n      }\n\n      let mapFn\n\n      if (headerCell !== void 0) {\n        mapFn = col => headerCell({\n          col, cols: this.computedCols, sort: this.sort, colsMap: this.computedColsMap\n        })\n      }\n      else {\n        mapFn = col => {\n          const props = {\n            col, cols: this.computedCols, sort: this.sort, colsMap: this.computedColsMap\n          }\n          const slot = this.$scopedSlots[`header-cell-${col.name}`]\n\n          return slot !== void 0\n            ? slot(props)\n            : h(QTh, {\n              key: col.name,\n              props: { props },\n              style: col.style,\n              class: col.classes\n            }, col.label)\n        }\n      }\n\n      const child = this.computedCols.map(mapFn)\n\n      if (this.singleSelection === true && this.grid !== true) {\n        child.unshift(h('th', { staticClass: 'q-table--col-auto-width' }, [' ']))\n      }\n      else if (this.multipleSelection === true) {\n        child.unshift(h('th', { staticClass: 'q-table--col-auto-width' }, [\n          h(QCheckbox, {\n            props: {\n              color: this.color,\n              value: this.someRowsSelected ? null : this.allRowsSelected,\n              dark: this.dark,\n              dense: this.dense\n            },\n            on: {\n              input: val => {\n                if (this.someRowsSelected) {\n                  val = false\n                }\n                this.__updateSelection(\n                  this.computedRows.map(row => row[this.rowKey]),\n                  this.computedRows,\n                  val\n                )\n              }\n            }\n          })\n        ]))\n      }\n\n      return h('tr', {\n        style: this.tableHeaderStyle,\n        class: this.tableHeaderClass\n      }, child)\n    },\n\n    addTableHeaderRowMeta (data) {\n      if (this.multipleSelection === true) {\n        Object.defineProperty(data, 'selected', {\n          get: () => this.someRowsSelected ? 'some' : this.allRowsSelected,\n          set: val => {\n            if (this.someRowsSelected) {\n              val = false\n            }\n            this.__updateSelection(\n              this.computedRows.map(row => row[this.rowKey]),\n              this.computedRows,\n              val\n            )\n          },\n          configurable: true,\n          enumerable: true\n        })\n        data.partialSelected = this.someRowsSelected\n        data.multipleSelect = true\n      }\n\n      return data\n    }\n  }\n}\n"]}]}