{"remainingRequest":"/home/witalo/go/src/github.com/witalok2/application/frontend/node_modules/babel-loader/lib/index.js!/home/witalo/go/src/github.com/witalok2/application/frontend/node_modules/quasar/src/utils/position-engine.js","dependencies":[{"path":"/home/witalo/go/src/github.com/witalok2/application/frontend/node_modules/quasar/src/utils/position-engine.js","mtime":499162500000},{"path":"/home/witalo/go/src/github.com/witalok2/application/frontend/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/home/witalo/go/src/github.com/witalok2/application/frontend/node_modules/babel-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es7.array.includes\";\nimport \"core-js/modules/es6.string.includes\";\nimport \"core-js/modules/es6.regexp.split\";\nimport { getScrollbarWidth } from \"./scroll.js\";\nexport function validatePosition(pos) {\n  var parts = pos.split(' ');\n\n  if (parts.length !== 2) {\n    return false;\n  }\n\n  if (!['top', 'center', 'bottom'].includes(parts[0])) {\n    console.error('Anchor/Self position must start with one of top/center/bottom');\n    return false;\n  }\n\n  if (!['left', 'middle', 'right'].includes(parts[1])) {\n    console.error('Anchor/Self position must end with one of left/middle/right');\n    return false;\n  }\n\n  return true;\n}\nexport function validateOffset(val) {\n  if (!val) {\n    return true;\n  }\n\n  if (val.length !== 2) {\n    return false;\n  }\n\n  if (typeof val[0] !== 'number' || typeof val[1] !== 'number') {\n    return false;\n  }\n\n  return true;\n}\nexport function parsePosition(pos) {\n  var parts = pos.split(' ');\n  return {\n    vertical: parts[0],\n    horizontal: parts[1]\n  };\n}\nexport function validateCover(val) {\n  if (val === true || val === false) {\n    return true;\n  }\n\n  return validatePosition(val);\n}\nexport function getAnchorProps(el, offset) {\n  var _el$getBoundingClient = el.getBoundingClientRect(),\n      top = _el$getBoundingClient.top,\n      left = _el$getBoundingClient.left,\n      right = _el$getBoundingClient.right,\n      bottom = _el$getBoundingClient.bottom,\n      width = _el$getBoundingClient.width,\n      height = _el$getBoundingClient.height;\n\n  if (offset !== void 0) {\n    top -= offset[1];\n    left -= offset[0];\n    bottom += offset[1];\n    right += offset[0];\n    width += offset[0];\n    height += offset[1];\n  }\n\n  return {\n    top: top,\n    left: left,\n    right: right,\n    bottom: bottom,\n    width: width,\n    height: height,\n    middle: left + (right - left) / 2,\n    center: top + (bottom - top) / 2\n  };\n}\nexport function getTargetProps(el) {\n  return {\n    top: 0,\n    center: el.offsetHeight / 2,\n    bottom: el.offsetHeight,\n    left: 0,\n    middle: el.offsetWidth / 2,\n    right: el.offsetWidth\n  };\n} // cfg: { el, anchorEl, anchorOrigin, selfOrigin, offset, absoluteOffset, cover, fit, maxHeight, maxWidth }\n\nexport function setPosition(cfg) {\n  var anchorProps; // scroll position might change\n  // if max-height changes, so we\n  // need to restore it after we calculate\n  // the new positioning\n\n  var scrollTop = cfg.el.scrollTop;\n  cfg.el.style.maxHeight = cfg.maxHeight;\n  cfg.el.style.maxWidth = cfg.maxWidth;\n\n  if (cfg.absoluteOffset === void 0) {\n    anchorProps = getAnchorProps(cfg.anchorEl, cfg.cover === true ? [0, 0] : cfg.offset);\n  } else {\n    var _cfg$anchorEl$getBoun = cfg.anchorEl.getBoundingClientRect(),\n        anchorTop = _cfg$anchorEl$getBoun.top,\n        anchorLeft = _cfg$anchorEl$getBoun.left,\n        top = anchorTop + cfg.absoluteOffset.top,\n        left = anchorLeft + cfg.absoluteOffset.left;\n\n    anchorProps = {\n      top: top,\n      left: left,\n      width: 1,\n      height: 1,\n      right: left + 1,\n      center: top,\n      middle: left,\n      bottom: top + 1\n    };\n  }\n\n  if (cfg.fit === true || cfg.cover === true) {\n    cfg.el.style.minWidth = anchorProps.width + 'px';\n\n    if (cfg.cover === true) {\n      cfg.el.style.minHeight = anchorProps.height + 'px';\n    }\n  }\n\n  var targetProps = getTargetProps(cfg.el),\n      props = {\n    top: anchorProps[cfg.anchorOrigin.vertical] - targetProps[cfg.selfOrigin.vertical],\n    left: anchorProps[cfg.anchorOrigin.horizontal] - targetProps[cfg.selfOrigin.horizontal]\n  };\n  applyBoundaries(props, anchorProps, targetProps, cfg.anchorOrigin, cfg.selfOrigin);\n  cfg.el.style.top = Math.max(0, Math.floor(props.top)) + 'px';\n  cfg.el.style.left = Math.max(0, Math.floor(props.left)) + 'px';\n\n  if (props.maxHeight !== void 0) {\n    cfg.el.style.maxHeight = Math.floor(props.maxHeight) + 'px';\n  }\n\n  if (props.maxWidth !== void 0) {\n    cfg.el.style.maxWidth = Math.floor(props.maxWidth) + 'px';\n  } // restore scroll position\n\n\n  if (cfg.el.scrollTop !== scrollTop) {\n    cfg.el.scrollTop = scrollTop;\n  }\n}\n\nfunction applyBoundaries(props, anchorProps, targetProps, anchorOrigin, selfOrigin) {\n  var margin = getScrollbarWidth();\n  var _window = window,\n      innerHeight = _window.innerHeight,\n      innerWidth = _window.innerWidth; // don't go bellow scrollbars\n\n  innerHeight -= margin;\n  innerWidth -= margin;\n\n  if (props.top < 0 || props.top + targetProps.bottom > innerHeight) {\n    if (selfOrigin.vertical === 'center') {\n      props.top = anchorProps[selfOrigin.vertical] > innerHeight / 2 ? innerHeight - targetProps.bottom : 0;\n      props.maxHeight = Math.min(targetProps.bottom, innerHeight);\n    } else if (anchorProps[selfOrigin.vertical] > innerHeight / 2) {\n      var anchorY = Math.min(innerHeight, anchorOrigin.vertical === 'center' ? anchorProps.center : anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.bottom : anchorProps.top);\n      props.maxHeight = Math.min(targetProps.bottom, anchorY);\n      props.top = Math.max(0, anchorY - props.maxHeight);\n    } else {\n      props.top = anchorOrigin.vertical === 'center' ? anchorProps.center : anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.top : anchorProps.bottom;\n      props.maxHeight = Math.min(targetProps.bottom, innerHeight - props.top);\n    }\n  }\n\n  if (props.left < 0 || props.left + targetProps.right > innerWidth) {\n    props.maxWidth = Math.min(targetProps.right, innerWidth);\n\n    if (selfOrigin.horizontal === 'middle') {\n      props.left = anchorProps[selfOrigin.horizontal] > innerWidth / 2 ? innerWidth - targetProps.right : 0;\n    } else if (anchorProps[selfOrigin.horizontal] > innerWidth / 2) {\n      var anchorX = Math.min(innerWidth, anchorOrigin.horizontal === 'middle' ? anchorProps.center : anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.right : anchorProps.left);\n      props.maxWidth = Math.min(targetProps.right, anchorX);\n      props.left = Math.max(0, anchorX - props.maxWidth);\n    } else {\n      props.left = anchorOrigin.horizontal === 'middle' ? anchorProps.center : anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.left : anchorProps.right;\n      props.maxWidth = Math.min(targetProps.right, innerWidth - props.left);\n    }\n  }\n}",{"version":3,"sources":["/home/witalo/go/src/github.com/witalok2/application/frontend/node_modules/quasar/src/utils/position-engine.js"],"names":["getScrollbarWidth","validatePosition","pos","parts","split","length","includes","console","error","validateOffset","val","parsePosition","vertical","horizontal","validateCover","getAnchorProps","el","offset","getBoundingClientRect","top","left","right","bottom","width","height","middle","center","getTargetProps","offsetHeight","offsetWidth","setPosition","cfg","anchorProps","scrollTop","style","maxHeight","maxWidth","absoluteOffset","anchorEl","cover","anchorTop","anchorLeft","fit","minWidth","minHeight","targetProps","props","anchorOrigin","selfOrigin","applyBoundaries","Math","max","floor","margin","window","innerHeight","innerWidth","min","anchorY","anchorX"],"mappings":"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","sourcesContent":["import { getScrollbarWidth } from './scroll.js'\n\nexport function validatePosition (pos) {\n  let parts = pos.split(' ')\n  if (parts.length !== 2) {\n    return false\n  }\n  if (!['top', 'center', 'bottom'].includes(parts[0])) {\n    console.error('Anchor/Self position must start with one of top/center/bottom')\n    return false\n  }\n  if (!['left', 'middle', 'right'].includes(parts[1])) {\n    console.error('Anchor/Self position must end with one of left/middle/right')\n    return false\n  }\n  return true\n}\n\nexport function validateOffset (val) {\n  if (!val) { return true }\n  if (val.length !== 2) { return false }\n  if (typeof val[0] !== 'number' || typeof val[1] !== 'number') {\n    return false\n  }\n  return true\n}\n\nexport function parsePosition (pos) {\n  let parts = pos.split(' ')\n  return { vertical: parts[0], horizontal: parts[1] }\n}\n\nexport function validateCover (val) {\n  if (val === true || val === false) { return true }\n  return validatePosition(val)\n}\n\nexport function getAnchorProps (el, offset) {\n  let { top, left, right, bottom, width, height } = el.getBoundingClientRect()\n\n  if (offset !== void 0) {\n    top -= offset[1]\n    left -= offset[0]\n    bottom += offset[1]\n    right += offset[0]\n\n    width += offset[0]\n    height += offset[1]\n  }\n\n  return {\n    top,\n    left,\n    right,\n    bottom,\n    width,\n    height,\n    middle: left + (right - left) / 2,\n    center: top + (bottom - top) / 2\n  }\n}\n\nexport function getTargetProps (el) {\n  return {\n    top: 0,\n    center: el.offsetHeight / 2,\n    bottom: el.offsetHeight,\n    left: 0,\n    middle: el.offsetWidth / 2,\n    right: el.offsetWidth\n  }\n}\n\n// cfg: { el, anchorEl, anchorOrigin, selfOrigin, offset, absoluteOffset, cover, fit, maxHeight, maxWidth }\nexport function setPosition (cfg) {\n  let anchorProps\n\n  // scroll position might change\n  // if max-height changes, so we\n  // need to restore it after we calculate\n  // the new positioning\n  const scrollTop = cfg.el.scrollTop\n\n  cfg.el.style.maxHeight = cfg.maxHeight\n  cfg.el.style.maxWidth = cfg.maxWidth\n\n  if (cfg.absoluteOffset === void 0) {\n    anchorProps = getAnchorProps(cfg.anchorEl, cfg.cover === true ? [0, 0] : cfg.offset)\n  }\n  else {\n    const\n      { top: anchorTop, left: anchorLeft } = cfg.anchorEl.getBoundingClientRect(),\n      top = anchorTop + cfg.absoluteOffset.top,\n      left = anchorLeft + cfg.absoluteOffset.left\n\n    anchorProps = { top, left, width: 1, height: 1, right: left + 1, center: top, middle: left, bottom: top + 1 }\n  }\n\n  if (cfg.fit === true || cfg.cover === true) {\n    cfg.el.style.minWidth = anchorProps.width + 'px'\n    if (cfg.cover === true) {\n      cfg.el.style.minHeight = anchorProps.height + 'px'\n    }\n  }\n\n  const\n    targetProps = getTargetProps(cfg.el),\n    props = {\n      top: anchorProps[cfg.anchorOrigin.vertical] - targetProps[cfg.selfOrigin.vertical],\n      left: anchorProps[cfg.anchorOrigin.horizontal] - targetProps[cfg.selfOrigin.horizontal]\n    }\n\n  applyBoundaries(props, anchorProps, targetProps, cfg.anchorOrigin, cfg.selfOrigin)\n\n  cfg.el.style.top = Math.max(0, Math.floor(props.top)) + 'px'\n  cfg.el.style.left = Math.max(0, Math.floor(props.left)) + 'px'\n\n  if (props.maxHeight !== void 0) {\n    cfg.el.style.maxHeight = Math.floor(props.maxHeight) + 'px'\n  }\n  if (props.maxWidth !== void 0) {\n    cfg.el.style.maxWidth = Math.floor(props.maxWidth) + 'px'\n  }\n\n  // restore scroll position\n  if (cfg.el.scrollTop !== scrollTop) {\n    cfg.el.scrollTop = scrollTop\n  }\n}\n\nfunction applyBoundaries (props, anchorProps, targetProps, anchorOrigin, selfOrigin) {\n  const margin = getScrollbarWidth()\n  let { innerHeight, innerWidth } = window\n\n  // don't go bellow scrollbars\n  innerHeight -= margin\n  innerWidth -= margin\n\n  if (props.top < 0 || props.top + targetProps.bottom > innerHeight) {\n    if (selfOrigin.vertical === 'center') {\n      props.top = anchorProps[selfOrigin.vertical] > innerHeight / 2\n        ? innerHeight - targetProps.bottom\n        : 0\n      props.maxHeight = Math.min(targetProps.bottom, innerHeight)\n    }\n    else if (anchorProps[selfOrigin.vertical] > innerHeight / 2) {\n      const anchorY = Math.min(\n        innerHeight,\n        anchorOrigin.vertical === 'center'\n          ? anchorProps.center\n          : (anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.bottom : anchorProps.top)\n      )\n      props.maxHeight = Math.min(targetProps.bottom, anchorY)\n      props.top = Math.max(0, anchorY - props.maxHeight)\n    }\n    else {\n      props.top = anchorOrigin.vertical === 'center'\n        ? anchorProps.center\n        : (anchorOrigin.vertical === selfOrigin.vertical ? anchorProps.top : anchorProps.bottom)\n      props.maxHeight = Math.min(targetProps.bottom, innerHeight - props.top)\n    }\n  }\n\n  if (props.left < 0 || props.left + targetProps.right > innerWidth) {\n    props.maxWidth = Math.min(targetProps.right, innerWidth)\n    if (selfOrigin.horizontal === 'middle') {\n      props.left = anchorProps[selfOrigin.horizontal] > innerWidth / 2 ? innerWidth - targetProps.right : 0\n    }\n    else if (anchorProps[selfOrigin.horizontal] > innerWidth / 2) {\n      const anchorX = Math.min(\n        innerWidth,\n        anchorOrigin.horizontal === 'middle'\n          ? anchorProps.center\n          : (anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.right : anchorProps.left)\n      )\n      props.maxWidth = Math.min(targetProps.right, anchorX)\n      props.left = Math.max(0, anchorX - props.maxWidth)\n    }\n    else {\n      props.left = anchorOrigin.horizontal === 'middle'\n        ? anchorProps.center\n        : (anchorOrigin.horizontal === selfOrigin.horizontal ? anchorProps.left : anchorProps.right)\n      props.maxWidth = Math.min(targetProps.right, innerWidth - props.left)\n    }\n  }\n}\n"]}]}